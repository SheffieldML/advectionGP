import numpy as np
from advectionGP.models.mesh_model import MeshModel

class SimpleODEModel(MeshModel):
    def __init__(self,boundary,resolution,kernel,noiseSD,sensormodel,windmodel,k_0,R,N_feat=25):
        """
        TODO: Maybe inherit from AdvectionDiffusionReaction1DModel as the constructor is the same.
        """
        super().__init__(boundary,resolution,kernel,noiseSD,sensormodel,N_feat)
        self.windmodel = windmodel
        self.u = self.windmodel.getu(self) #advection term: size 2 x resolution grid
        self.k_0 = k_0
        self.R=R
        delta,Ns = self.getGridStepSize()
        if (delta[1]>=2*self.k_0/np.min(np.abs(self.u))): print("WARNING: spatial grid size does not meet the finite difference advection diffusion stability criteria")
        if (delta[0]>=delta[1]**2/(2*self.k_0)): print("WARNING: temporal grid size does not meet the finite difference advection diffusion stability criteria")
                
    def computeConcentration(self,source,enforce_nonnegative=False):
        """
        Computes concentrations.
        Arguments:
         source == forcing function (shape: Nt x Nx x Ny). Can either be generated by ... or determine manually.
         enforce_nonnegative = default False,. Setting to true will force concentration to be non-negative each iteration.
        returns array of concentrations (shape: Nt x Nx x Ny), given source. (also saved it in self.concentration)
        """
        #source = self.source
        
        #get the grid step sizes, their squares and the size of the grid
        delta, Ns = self.getGridStepSize()
        dt = delta[0]
        Nt = Ns[0]
        
        c=np.zeros(((self.resolution)))
        
        c[0,:,:]=0

        for i in range(0,Nt-1):
            # Internal Calc
            c[i+1,:,:]=c[i,:,:] +dt*(source[i,:,:])
            if enforce_nonnegative: c[c<0]=0
        concentration = c 
        
        self.conc = concentration
        return c      

class AdjointSimpleODEModel(SimpleODEModel):
    def computeAdjoint(self,H):
        """
        Runs the backward PDE (adjoint problem)
        Gets called for an observation instance (H).
        (v is the result of the adjoint operation)
        """
        delta, Ns = self.getGridStepSize()
        dt = delta[0]
        Nt = Ns[0]

        v=np.zeros(((Nt)))
        v[-1,:,:]=0.0
        for i in range(1,Nt): #TODO might be better to rewrite as range(Nt-1,1,-1)...
        #Internal calculation (not on the boundary)
            v[-i-1,:,:]=v[-i,:,:] +dt*( H[-i,:,:])
        return v
